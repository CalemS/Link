// Generated by CoffeeScript 1.6.3
(function() {
  var LinkPublisher, LinkSequenceBuilder;

  LinkSequenceBuilder = require("./link").LinkSequenceBuilder;

  LinkPublisher = (function() {
    function LinkPublisher(client) {
      this.client = client;
    }

    LinkPublisher.prototype.encodeAddresses = function(message) {
      var sequence;
      sequence = new LinkSequenceBuilder(this.client.version);
      if (message.payloadInline != null) {
        sequence.addPayloadInline(message.payloadInline);
      }
      if (message.name != null) {
        sequence.addName(message.name);
      }
      if (message.keywords != null) {
        sequence.addKeywords(message.keywords);
      }
      if (message.description != null) {
        sequence.addDescription(message.description);
      }
      if (message.originalCreationDate != null) {
        sequence.addOriginalCreationDate(message.originalCreationDate);
      }
      if (message.lastModifiedDate != null) {
        sequence.addLastModifiedDate(message.lastModifiedDate);
      }
      if (message.license != null) {
        sequence.addLicense(message.license);
      }
      return sequence.getAddresses();
    };

    LinkPublisher.prototype.getMessageCost = function(addresses) {
      return parseFloat(((addresses.length * 0.02) + (addresses.length * 0.00000001)).toFixed(8));
    };

    LinkPublisher.prototype.publish = function(message, callback) {
      var addresses, client, outs, total, x, _i, _len;
      addresses = this.encodeAddresses(message);
      total = this.getMessageCost(addresses);
      client = this.client;
      outs = {};
      for (_i = 0, _len = addresses.length; _i < _len; _i++) {
        x = addresses[_i];
        outs[x] = 0.00000001;
      }
      return client.listUnspent(0, function(err, unspent) {
        var tx, useable, _j, _len1;
        useable = void 0;
        for (_j = 0, _len1 = unspent.length; _j < _len1; _j++) {
          tx = unspent[_j];
          if (parseFloat(tx.amount.toFixed(8)) >= total && ((useable == null) || parseFloat(useable.amount.toFixed(8)) > parseFloat(tx.amount.toFixed(8)))) {
            useable = tx;
          }
        }
        if (useable == null) {
          return callback("No unspent");
        }
        if (useable.amount > total) {
          outs[useable.address] = useable.amount - total;
        }
        return client.createRawTransaction([useable], outs, function(err, rawtx) {
          return client.decodeRawTransaction(rawtx, function(error, decoded) {
            return client.signRawTransaction(rawtx, [useable], function(error, decoded) {
              return client.sendRawTransaction(decoded.hex, function(error, result) {
                if (callback != null) {
                  return callback(result);
                }
              });
            });
          });
        });
      });
    };

    return LinkPublisher;

  })();

  exports.LinkPublisher = LinkPublisher;

}).call(this);
